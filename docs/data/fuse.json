{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Root","n":1},"1":{"v":"# Welcome to Dendron\n\nThis is Richard Landingpage\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)\n","n":0.204}}},{"i":2,"$":{"0":{"v":"Proggramming Language","n":0.707}}},{"i":3,"$":{"0":{"v":"Makefile","n":1},"1":{"v":"\n\n### What is Makefile\n\nFile type that is used for compiling and linking programs from source code files. Makefiles contain five kinds of things: explicit rules, implicit rules, variable definitions, directives, and comments.\n\n### Useful Makefile\n\nThis make file can be usefull for small projects\n\n```shell\n\nCC=gcc\nRM=rm\nCFLAGS=-g -Wall\nOBJS=somefile.o\nBIN=main\n\nall:$(BIN)\n\nmain:$(OBJS)\n    $(CC) $(CFLAGS) $(OBJS) -o main\n\n%.o: %.c\n    $(CC) $(CFLAGS) -c $< -o $@\n\nclean: \n    $(RM) -r main *.o\n\n```\n","n":0.129}}},{"i":4,"$":{"0":{"v":"C++","n":1},"1":{"v":"\n\n## Information\n\nHere I will start inserting all the noted related to C++ from my front website\n\n\n**[[Proggramming Language.C++.C++V11]]**: Information about some of the features added in C++ Version 11\n\n**[[Proggramming Language.C++.C++ Streams]]**: Some of the methods for handling streams and buffers in C++.\n\n**[[Proggramming Language.C++.C++ Const]]**: How to use the `const` keyword and some examples.\n\n**[[Proggramming Language.C++.C++ Compiler Generated Functions]]**: When compaling on C++(G++) there are several function that are implicitly added. \n\n","n":0.12}}},{"i":5,"$":{"0":{"v":"C++V11","n":1},"1":{"v":"\n\n## C++ 11 [Link to Video](https://www.youtube.com/watch?v=U6mgsPqV32A&t=23s&ab_channel=BoQian)\n\n> This are notes taking from videos in BoQian Channel, for learning purpose.\n\n### Initializer List\n\n```cpp\n\n//C++ 03 initializer list:\nint arr[4] = {3, 2, 4, 5};\n\nvector<int> v;\nv.push_back(3);\nv.push_back(2);\nv.push_back(4);\nv.push_back(5);\n\n// C++ 11 extended the support \nvector<int> v = {3, 4, 1, 9};   // Calling initializer_list constructor\n// All the relevant STL containers have been updated to accept initializer_list.\n\n```\n\n```cpp\n// Define your own initializer_list constructor:\n#include <initializer_list>\nclass BoVector {\n   vector<int> m_vec;\n   public:\n   BoVector(const initializer_list<int>& v) {\n      for (initializer_list<int>::iterator itr = v.begin(); itr!=v.end(); ++ itr)\n         m_vec.push_back(*itr);\n   }\n};\n\nBoVector v = {0, 2, 3, 4};\nBoVector v{0, 2, 3, 4};   // effectively the same\n\n```\n\n### Uniform Initialization\n\n\n```cpp\n\n// C++ 03\nclass Dog {     // Aggregate class or struct\n   public:\n      int age;\n      string name;\n};\nDog d1 = {5, \"Henry\"};   // Aggregate Initialization\n\n// C++ 11 extended the scope of curly brace initialization\nclass Dog {\n   public:\n      Dog(int age, string name) {...};\n};\nDog d1 = {5, \"Henry\"}; \n\n```\n\nUniform Initialization Search Order(Compiler):\n1. Initializer_list constructor\n2. Regular constructor that takes the appropriate parameters.\n3. Aggregate initializer.\n\nExample:\n\n```cpp\nDog d1{3};\n\nclass Dog {\n   public:\n   int age;                                // 3rd choice\n\n   Dog(int a) {                            // 2nd choice\n      age = a;\n   }\n\n   Dog(const initializer_list<int>& vec) { // 1st choice\n      age = *(vec.begin());      \n   }\n};\n```\n\n### Auto Type\n\n```cpp\nstd::vector<int> vec = {2, 3, 4, 5};\n\n// C++ 03\nfor (std::vector<int>::iterator it = vec.begin(); it!=vec.end(); ++ it)\n    m_vec.push_back(*it);\n\n\n// C++ 11: use auto type\nfor (auto it = vec.begin(); it!=vec.end(); ++ it)\n    m_vec.push_back(*it);\n\nauto a = 6;    // a is a integer\nauto b = 9.6;  // b is a double\nauto c = a;    // c is an integer\n\nauto const x = a;   // int const x = a\nauto& y = a;        // int& y = a\n\n// It's static type, no run-time cost\n// It also makes code easier to maintain.\n\n// 1. Don't use auto when type conversion is needed\n// 2. IDE becomes more important\n\n```\n\n### foreach \n\n```cpp\n\n// C++ 03:\n   for (vector<int>::iterator itr = v.begin(); itr!=v.end(); ++ itr)\n      cout << (*itr);\n\n\n// C++ 11:\n   for (auto i: v) { // works on any class that has begin() and end()\n      cout << i ;    // readonly access\n   }\n\n   for (auto& i: v) {\n      i++;                 // changes the values in v\n   }                       // and also avoids copy construction\n\n   auto x = begin(v);  // Same as: int x = v.begin();\n\n   int arr[4] = {3, 2, 4, 5};\n   auto y = begin(arr); // y == 3\n   auto z = end(arr);   // z == 5\n   // How this worked? Because begin() and end() are defined for array.\n   // Adapt your code to third party library by defining begin() and end()\n   // for their containers.\n\n```\n\n### nullptr\n\n> To replace NULL in C++ 03\n\n```cpp\nvoid foo(int i) { cout << \"foo_int\" << endl; }\nvoid foo(char* pc) { cout << \"foo_char*\" << endl; }\n\nint main() {\n   foo(NULL);    // Ambiguity\n\n   // C++ 11\n   foo(nullptr); // call foo(char*)\n}\n```\n\n### enum class\n\n```cpp\n // C++ 03\n   enum apple {green_a, red_a};\n   enum orange {big_o, small_o};\n   apple a = green_a;\n   orange o = big_o;\n\n   if (a == o) \n      cout << \"green apple and big orange are the same\\n\";\n   else\n      cout << \"green apple and big orange are not the same\\n\";\n\n\n   // C++ 11\n   enum class apple {green, red};\n   enum class orange {big, small};\n   apple a = apple::green;\n   orange o = orange::big;\n\n   if (a == o) \n      cout << \"green apple and big orange are the same\\n\";\n   else\n      cout << \"green apple and big orange are not the same\\n\";\n\n   // Compile fails because we haven't define ==(apple, orange)\n\n\n```\n\n### static assert\n\n```cpp\n// run-time assert\n   assert( myPointer != NULL );\n\n// Compile time assert (C++ 11)\n   static_assert( sizeof(int) == 4 );\n```\n\n### delegating constructor\n\n```cpp\n// C++ 03:\nclass Dog {\n   init() { ... };\n   public:\n   Dog() { init(); }\n   Dog(int a) { init(); doOtherThings(); }\n};\n/* Cons:\n * 1. Cumbersome code.\n * 2. init() could be invoked by other functions.\n */\n\n// C++ 11:\nclass Dog {\n   int age = 9;\n   public:\n   Dog() { ... }\n   Dog(int a) : Dog() { doOtherThings(); }\n};\n// Limitation: Dog() has to be called first.\n\n```\n\n### constexpr\n\n```cpp\n\nint arr[6];    //OK\nint A() { return 3; }\nint arr[A()+3];   // Compile Error \n\n// C++ 11\nconstexpr int A() { return 3; }  // Forces the computation to happen \n                                 // at compile time.\nint arr[A()+3];   // Create an array of size 6\n\n// Write faster program with constexpr\nconstexpr int cubed(int x) { return x * x * x; }\n\nint y = cubed(1789);  // computed at compile time\n\n//Function cubed() is:\n//1. Super fast. It will not consume run-time cycles\n//2. Super small. It will not occupy space in binary.\n\n\n```\n\n### New string literals\n\n```cpp\n // C++ 03:\n  char*     a = \"string\";  \n\n  // C++ 11:\n  char*     a = u8\"string\";  // to define an UTF-8 string. \n  char16_t* b = u\"string\";   // to define an UTF-16 string. \n  char32_t* c = U\"string\";   // to define an UTF-32 string. \n  char*     d = R\"string \\\\\"    // to define raw string. \n\n\n```\n\n### Keyword final\n\n```cpp\nclass Dog final {    // no class can be derived from Dog\n   ...\n};\n   \nclass Dog {\n   virtual void bark() final;  // No class can override bark() \n};\n```\n\n### Keyword delete\n\n```cpp\nclass Dog {\n   Dog(int age) {}\n}\n\nDog a(2);\nDog b(3.0); // 3.0 is converted from double to int\na = b;     // Compiler generated assignment operator\n\n// preventing the user from using a class different manner\n// C++ 11:\nclass Dog {\n   Dog(int age) {}\n   Dog(double ) = delete; //\n   Dog& operator=(const Dog&) = delete;\n}\n\n```\n\n### Keyword default (for default constructor)\n\n```cpp\nclass Dog {\n   Dog(int age) {}\n};\n\nDog d1;  // Error: compiler will not generate the default constructor\n\n\n// C++ 11:\nclass Dog {\n   Dog(int age);\n   Dog() = default;    // Force compiler to generate the default constructor\n};\n\n\n```\n\n### Keyword override (for virtual function)\n\n```cpp\n\n// C++ 03\nclass Dog {\n   virtual void A(int);\n   virtual void B() const;\n}\n\nclass Yellowdog : public Dog {\n   virtual void A(float);  // Created a new function\n   virtual void B(); // Created a new function \n}\n\n\n// C++ 11\nclass Dog {\n   virtual void A(int);\n   virtual void B() const;\n   void C();\n}\n\nclass Yellowdog : public Dog {\n   virtual void A(float) override;  // Error: no function to override\n   virtual void B() override;       // Error: no function to override\n   void C() override;               // Error: not a virtual function\n}\n\n\n```\n\n### Lambda Function\n\n```cpp\n\ncout << [](int x, int y){return x+y}(3,4) << endl;  // Output: 7\nauto f = [](int x, int y) { return x+y; };\ncout << f(3,4) << endl;   // Output: 7\n\n\ntemplate<typename func>\nvoid filter(func f, vector<int> arr) {\n   for (auto i: arr) {\n      if (f(i))\n         cout << i << \" \";\n   }\n}\n\nint main() {\n   vector<int> v = {1, 2, 3, 4, 5, 6 };\n\n   filter([](int x) {return (x>3);},  v);    // Output: 4 5 6\n   ...\n   filter([](int x) {return (x>2 && x<5);},  v); // Output: 3 4\n\n\n   int y = 4;  \n   filter([&](int x) {return (x>y);},  v);    // Output: 5 6\n   //Note: [&] tells compiler that we want variable capture\n}\n\n// Lambda function works almost like a language extention\ntemplate\nfor_nth_item\n\n```\n\n\n","n":0.03}}},{"i":6,"$":{"0":{"v":"C++ Streams","n":0.707},"1":{"v":"\n\n## Intro: [Link](https://www.youtube.com/watch?v=hk5NYscSPHI&list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&index=18&ab_channel=BoQian)\n\nWhat is stream?: Serial IO Interferface to external devices (file, stdin/stdout, network, etc.)\n\n\n```cpp\nstring s(\"Hello\");\ns[3] = 't'; // Random access\n//cout[3] = 't'; // Error\n\n{\nofstream of(\"MyLog.txt\"); // Creates a new file for write, if the file didn't exist\nof << \"Text\" << endl;\nof << 234 <<endl;\nof << 2.3 <<endl; \n\nof << bitset<8>(14) << endl; // 00001110\nof << complex<int>(2,3) << endl; // (2,3)\n\n} //RAII\n\n```\n\nIO Operations:\n\nformatting the data  <-------->  communicatiing the data with external devices\n\nSoftware Engineer Principle: Low Couping -> Resuability\n\n\n## File Stream and Error Handling: [Link](https://www.youtube.com/watch?v=bzlDPBKn2Fs&list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&index=18&ab_channel=BoQian)\n\n\n**Ouput**: \n\n```cpp\n{\n    ofstream of(\"Log.txt\");// Open file for write , and clear the file\n    cout<< \"Text to the file\"<< endl;\n}\n\n{\n    ofstream of(\"Log.txt\", ofstream::app); // Move the output pointer to te end of the file\n    cout<< \"Text to the file\"<< endl;\n}\n{\n    ofstream of(\"Log.txt\", ofstream::in | ofstream::out);\n    of.seekp(10, ios::beg); // Move the output pointer 10 chars after begin\n    of << \"12345\"; // Overwrite 5 char\n    of.seekp(-5, ios::end); //Move the output  pointer 5 chars before end\n    of << \"More text, more text\" << endl;\n    of.seekp(-5, ios::cur); // Move the ouput pointer 5 char before the current position\n}\n```\n\n**Input**: \n\n```cpp\n{\n    ifstream inf(\"Log.txt\");\n    int i;\n    inf >> i; // read one word\n    // Error status: goodbit, badbit, failbit, eofbit\n    inf.good(); // Everything is OK (goodbit = 1)\n    inf.bad(); //Non-recoverable error (badbit = 1)\n    inf.fail(); //Failed Stream operation (failbit == 1 badbit == 1)\n    inf.eof(); // End of file (eofbit == 1)\n\n    inf.clear(); // Clear all error status\n    inf.clear(ios::badbit); // sets a new value to the error flag\n\n    inf.rdstate(); // Read the current status flag\n    inf.clear(inf.rdstate() & ~ios::failbit); // Clear only the failbit\n\n    if(inf) // Equivalent to: if (!inf.fail())\n        cout << \"Read successfully\"\n    \n    if(inf >> i)\n        cout << \"Read successfully\";\n\n    // Handle the errors with exceptions\n    inf.exceptions(ios::badbit | ios::failbit); // setting the exception mask\n    // When badbit or failbit set 1, exception of iosLLfailure will be thrown\n    // When eofbit set to 1, no exception \n    inf.exceptions(ios::goodbit); // No exception\n\n}\n```\n\n## Formatted and Unformatted IO: [Link](https://www.youtube.com/watch?v=CdZxKlC7Y-E&list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&index=19&ab_channel=BoQian)\n\n**Formatting IO**\n\n```cpp\n    \n    cout << 34 << endl; //34\n    cout.setf(ios::oct, ios::basefield);//ocatal\n    cout << 34; // 42\n    cout.setf(ios::showbase);\n    cout << 34; // 042\n    cout.setf(ios::hex, ios::basefield);\n    cout <<34; // 0x22\n\n    cout.unsetf(ios::showbase);\n    cout << 34; // 22\n\n    cout.setf(ios::dec, ios::basefield);\n\n    cout.width(10);\n    cout << 26 << endl; //          26\n    cout.setf(ios::left, ios::adjustfield);  //26\n\n    // Floating points values\n    cout.setf(ios::scientific, ios::floatfield); \n    cout << 340.1 << endl; // 3.401000e+002\n    cout.setf(ios::fixed, ios::floatfield);\n    cout << 340.1 << endl; //340.100000\n    cout.precision(3)l\n    cout << 340.1 << endl; //340.100\n\n    int i;\n    cin.setf(ios::hex, ios::basefield); \n    cin >> in // Enter: 12\n    //i==18\n\n    ios::fmtflags f = cout.flags(); //Current flags been used\n    cout.flags(ios::oct | ios::showbase);\n    cout.flags(); // returns ios::oct | ios::showbase\n\n```\n\n**Unformated IO**\n\n```cpp\n    ifstream inf(\"Log.txt\");\n    char buf[80];\n    inf.get(buf,80); // read up to 80 chars and save to buf\n    inf.getLine(buf, 80); //readu up to 80 or until a '\\n'\n    inf.read(buf, 80); // read 80 chars\n    inf.ignore(3);\n    inf.peek();\n    inf.unget(); // return a char back to the stream( retuns same last char)\n    inf.putback('z'); //returns a char 'z' to the stream\n    inf.get();\n    inf.gcount(); // return the number of  chars  being read  bu last unformatted read\n\n    //output\n    ofstream of(\"Log.txt\");\n    of.put('c');\n    of.write(buf, 6); // write first 6 chars of buf\n    of.flush(); // Flush output to screen in case of cout\n```\n\n\n## Manipulators: [Link](https://www.youtube.com/watch?v=yMseUJm1604&list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&index=20&ab_channel=BoQian)\n\nDescriptions: In this video [Bo Qian](https://www.youtube.com/channel/UCEOGtxYTB6vo6MQ-WQ9W_nQ) explains what are manipulators by using an example that is well know `std::endl`. A brief description concludes that endl is a fucntion that **manipulates** the stream.\n\n```cpp\n\n    ostream& endl(ostream& sm){ // Manipulator\n        sm.put('\\n');\n        sm.flush();\n        return sm;\n    }\n\n    ostream& ostream::operator<<(ostream& (*func)(ostream&)){\n        return (*func)(*this);\n    }\n\n    int main(){\n        cout << \"hello\" << endl; //endl: '\\n' and flush\n        // object? Build-in data type? function? (look to func above)\n\n        // More manipulators\n        cout << ends; //'\\0'\n        cout << flush;\n        cin >> ws; // read and discard white spaces\n        cout << setw(8) << left << setfill('_') << 99 << endl; //99______\n        cout << hex << showbase << 14; //0xe\n        \n        // More in: https://www.cplusplus.com/reference/ios/\n    }\n```\n\n## Stream Buffer: [Link](https://www.youtube.com/watch?v=HwtFcT-ueu8&list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&index=21&ab_channel=BoQian)\n\nIO Operations:\n* Formating data -- stream\n* Communicating data to external devices -- stream buffer\n\n```cpp\n\n    cout << 34; //Formatting\n    streambuf* pbuf = cout.rdbuf();\n\n    ostream myCout(pbuf);\n    myCout.setf(ios::showpos);\n    myCout.width(20);\n    myCout << 12 << endl; //        +12\n    cout << 12 << endl; //12\n    \n    //Redirecting\n    ofstream of(\"Log.txt\");\n    streambuf* oriBuf = cout.rdbuf(); // saving backup from original\n    cout.rdbuf(of.rdbuf());\n    cout << \"Hello\" << endl; // Log.txt has \"Hello\"\n\n    cout.rdbuf(oriBuf); // setting cout to original buffer\n\n    cout << \"Bye\" << endl; //stdout: Bye\n\n    //Stream buffer iterator\n    istreambuf_iterator<char> i(cin);\n    ostreambuf_iterator<char> o(cout);\n\n    // Copy\n    while(*i != 'x'){\n        *o = *i;\n        ++o;\n        ++i;\n    } // exit option if press x\n\n    //Similar to copy with no exit\n    copy(istreambuf_iterator<char>(cin), istreambuf_iterator<char>(), ostreambuf_iterator<char>(cout));\n\n```\n\n\n## String Stream : [Link](https://www.youtube.com/watch?v=VzM1GWUl8eI&list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&index=22&ab_channel=BoQian)\n\n```cpp\n\n    // Srtring Stream\n    stringstream ss; // Stream without IO operation\n    // read/write of string\n    // Example\n    ss << 89 << \" Hex: \" << hex << 89 << \" Oct: \" << oct << 89;\n    cout << ss.str() << endl; //89 Hex: 59 Oct: 131\n\n    int a, b, c;\n    string s1;\n\n    ss << hex >> a; // Formatted input works token by token, spaces, tabs, newlines\n        //a == 137\n    ss >> s1; // s1: \"Hex:\"\n    ss >> dec >> b; //b==59\n    \n    ss.ignore(6);\n\n    ss>> oct >> c; //c==89\n```\n\nRecommendation: `stringstream` is used in the example above for input and output but this fucntionality is also offered by two other stream class.\n\n* `ostringstream`: Used only for formatted output\n* `istringstream`: Used only for formatted input\n\nIt is recommended for readibility that we use the streams mention above, because they portray our intention for the given stream.\n\n\n## Enable Streaming for Your Own Class: [Link](https://www.youtube.com/watch?v=MefRKIml_1w&list=PL5jc9xFGsL8G3y3ywuFSvOuNm3GjBwdkb&index=23&ab_channel=BoQian)\n\nDescription: Class of `Dog` allows for IO Stream creating and outputing formatted data.\n\n```cpp\n\n    using namespace std;\n\n    //Creating Stream-enabled Class\n    struct Dog{\n        int age_;\n        string name_;\n    };\n\n    // Input Stream\n    ostream& operator<<(ostream& sm, const Dog& d){\n        sm << \"My name is \" << d.name_ << \" and my age is \" << d.age_ << endl;\n        return sm; \n    }\n\n    // Output Stream\n    istream& operator>>(istream& sm, Dog& d){\n        sm >> d.age_;\n        sm >> d.name_;\n        return sm;\n    }\n\n    int main(){\n        Dog d{2, \"Bob\"}; // Universal Initialization from c++11\n        cout << d;\n\n        cin >> d; // 5 carl [Input]\n        cin << d; //My name is carl and my age is 5 [Output]\n    }\n\n```\n","n":0.032}}},{"i":7,"$":{"0":{"v":"C++ Const","n":0.707},"1":{"v":"\n## `const` with functions\n\nReference: [Video](https://www.youtube.com/watch?v=RC7uE_wl1Uc&ab_channel=BoQian)\n\nUsing const in methods examples, and can be used for more efficiency.\n\n```cpp\n\nclass Dog {\n    // Class Memebers\n    int age;\n    string name;\n\n    public:\n    Dog() {age =3; name = \"dummy\";}\n    \n    // Const parameter\n    void setAge (const int& a ) {age = a;} // Correct[ pass by reference and can't be changed]\n    void setAge (const int a ) {age = a;} // const is not useful here\n    void setAge (int a ) {age = a;} // similar\n\n    //  Const return value\n    const string& getName() {return name;}; // pass by reference \"more efficient\"\n\n    //const function [Means it will not modify any members of the class]\n    void printDogName() const {\n        cout << getName() << \"const\" << endl; // const functions can only called const functions\n    }\n    // Overload const function (will be called if instance of the class is const)\n    void printDogName() {\n        cout << name << \"non-const\" << endl; // const functions can only called const functions\n    } \n     \n}\n\nint main(){\n    // Call regular\n    Dog d;\n    d.printDogName();\n\n    // Call overloaded \n    const Dog d2;\n    d2.printDogName();\n    }\n\n\n```\n\n\n\n","n":0.075}}},{"i":8,"$":{"0":{"v":"C++ Compiler Generated Functions","n":0.5},"1":{"v":"\n\n\n## What are generated functions:\n\nReference: [Video](https://www.youtube.com/watch?v=KMSYmY74AEs&ab_channel=BoQian)\n\nThis are functions that the compiler adds when you don't explicitly declare them(only if is required):\n1. Copy constructor\n2. Copy Assigment Operator\n3. Destructor\n4. Default constructor (only if there is not contructor declared)\n\n\n```cpp \n\nclass Dog{};\n\n// similar to\n\nclass Dog{\n\n    dog(const dog& rhs) {...} //Member by Member initialization\n    dog& operator=(const dog& rhs ) {...}; // Member by Member copying\n    dog() {...}; // 1- Call base class's default constructor\n                 // 2- Call data member's default constructor. \n    ~dog() {...};// 1- Call data class's destructor.\n                 // 2- Call data member's destructor. \n}\n\n```\n\nAdditional Information:\n1. These are public and inline.\n2. They are generatedd only if they are needed\n3. A `default constructor` is a constructor that can work without any parameters.\n\n\n","n":0.092}}},{"i":9,"$":{"0":{"v":"Notes","n":1},"1":{"v":"\n\n### Information\n\nThis will be some of the notes related to classes and other information that may be disorganized.\n\n","n":0.236}}},{"i":10,"$":{"0":{"v":"Publish-Notes","n":1},"1":{"v":"\n\n## How to publish my Notes(Remainder):\n\nHere I will save several of the commands that are required to publish my notes to public. Also to get the most up to date notes please `git clone` the repository since the procedure for publishing needs to be performed by a computer that has all the requirements. Explain in the next section.\n\nReferences: [Here](https://wiki.dendron.so/notes/23a1b942-99af-45c8-8116-4f4bb7dccd21/)\n\n### Requirements:\n\n* `Node.js` is required\n* Intallation of `dendron-cli`\n\n```bash\n# intall\nnpm install -g @dendronhq/dendron-cli\n# upgrade\nnpm install -g @dendronhq/dendron-cli@latest\n\n```\n\n* Setup if it is the first time running in this workspace. Initialize dendron-cli\n\n```bash\n# Init nodejs\nnpm init -y \n# install in directory\nnpm install @dendronhq/dendron-cli\n\n# Update .gitignore\necho .next >> .gitignore\n# Clone the nextjs repository and install dependencies\nnpx dendron publish init\n```\n\n\n\n\n### Publishing Commands\n\nFor building and Previewing( `https://localhost:3000`):\n\n```bash\nnpx dendron publish dev\n```\n\n**For publishing we need to run a export with a `github` target:**\n\n```bash\ndendron publish export --target github\n\n# Deployment\ngit add .\ngit commit -m \"dendron page update\"\ngit push\n```\n\nAfter this the website should update in a few seconds.","n":0.081}}}]}
